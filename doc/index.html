<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.14.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>bstring: Better String library</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">bstring<span id="projectnumber">&#160;1.0.2</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.14.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Better String library </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="mainpage"></a></p>
<p><em>by Paul Hsieh</em></p>
<p>The bstring library is an attempt to provide improved string processing functionality to the C language. At the heart of the bstring library (Bstrlib for short) is the management of <span class="tt">bstring</span>s which are a significant improvement over <span class="tt">NULL</span> terminated char buffers.</p>
<h1 class="doxsection"><a class="anchor" id="autotoc_md15"></a>
Motivation</h1>
<p>The standard C string library has serious problems:</p>
<ol type="1">
<li>Its use of <span class="tt">NULL</span> to denote the end of the string means knowing a string's length is O(n) when it could be O(1).</li>
<li>It imposes an interpretation for the character value <span class="tt">NULL</span>.</li>
<li><span class="tt">gets</span> always exposes the application to a buffer overflow.</li>
<li><span class="tt">strtok</span> modifies the string its parsing and thus may not be usable in programs which are re-entrant or multithreaded.</li>
<li>fgets has the unusual semantic of ignoring <span class="tt">NULL</span>s that occur before newline characters are consumed.</li>
<li>There is no memory management, and actions performed such as <span class="tt">strcpy</span>, <span class="tt">strcat</span> and <span class="tt">sprintf</span> are common places for buffer overflows.</li>
<li><span class="tt">strncpy</span> doesn't <span class="tt">NULL</span> terminate the destination in some cases.</li>
<li>Passing NULL to C library string functions causes an undefined NULL pointer access.</li>
<li>Parameter aliasing (overlapping, or self-referencing parameters) within most C library functions has undefined behavior.</li>
<li>Many C library string function calls take integer parameters with restricted legal ranges. Parameters passed outside these ranges are not typically detected and cause undefined behavior.</li>
</ol>
<p>So the desire is to create an alternative string library that does not suffer from the above problems and adds in the following functionality:</p>
<ol type="1">
<li>Incorporate string functionality seen from other languages.<ul>
<li><span class="tt">MID</span> from BASIC</li>
<li><span class="tt">split</span>/<span class="tt">join</span> from Python</li>
<li><span class="tt">string</span>/<span class="tt">char</span> <span class="tt">x n</span> from Perl</li>
</ul>
</li>
<li>Implement analogs to functions that combine stream IO and char buffers without creating a dependency on stream IO functionality.</li>
<li>Implement the basic text editor-style functions <span class="tt">insert</span>, <span class="tt">delete</span>, <span class="tt">find</span>, and <span class="tt">replace</span>.</li>
<li>Implement reference based sub-string access (as a generalization of pointer arithmetic.)</li>
<li>Implement runtime write protection for strings.</li>
</ol>
<p>There is also a desire to avoid "API-bloat." So functionality that can be implemented trivially in other functionality is omitted. So there is no <span class="tt">left</span> or <span class="tt">right</span> or <span class="tt">reverse</span> or anything like that as part of the core functionality.</p>
<h1 class="doxsection"><a class="anchor" id="autotoc_md16"></a>
Explaining Bstrings</h1>
<p>A bstring is basically a header which wraps a pointer to a char buffer. Let's start with the declaration of a struct tagbstring: </p><pre class="fragment">struct tagbstring {
    int mlen;
    int slen;
    unsigned char * data;
};
</pre><p>This definition is considered exposed, not opaque (though it is neither necessary nor recommended that low level maintenance of bstrings be performed whenever the abstract interfaces are sufficient). The <span class="tt">mlen</span> field (usually) describes a lower bound for the memory allocated for the data field. The <span class="tt">slen</span> field describes the exact length for the bstring. The data field is a single contiguous buffer of unsigned chars. Note that the existence of a <span class="tt">NULL</span> character in the unsigned char buffer pointed to by the data field does not necessarily denote the end of the bstring.</p>
<p>To be a well formed modifiable bstring the <span class="tt">mlen</span> field must be at least the length of the <span class="tt">slen</span> field, and slen must be non-negative. Furthermore, the data field must point to a valid buffer in which access to the first <span class="tt">mlen</span> characters has been acquired. So the minimal check for correctness is: </p><pre class="fragment">(slen &gt;= 0 &amp;&amp; mlen &gt;= slen &amp;&amp; data != NULL)
</pre><p>Bstrings returned by bstring functions can be assumed to be either NULL or satisfy the above property. (When bstrings are only readable, the <span class="tt">mlen &gt;=
slen</span> restriction is not required; this is discussed later in this section.) A bstring itself is just a pointer to a <span class="tt">struct tagbstring</span>: </p><pre class="fragment">typedef struct tagbstring *bstring;
</pre><p>Bstrlib basically manages bstrings allocated as a header and an associated data-buffer. Since the implementation is exposed, they can also be constructed manually. Functions which mutate bstrings assume that the header and data buffer have been malloced; the bstring library may perform <span class="tt">free</span> or <span class="tt">realloc</span> on both the header and data buffer of any bstring parameter. Functions which return bstring's create new bstrings. The string memory is freed by a <span class="tt">bdestroy</span> call (or using the <span class="tt">bstrFree</span> macro).</p>
<p>Since bstrings maintain interoperability with C library char-buffer style strings, all functions which modify, update or create bstrings also append a <span class="tt">NULL</span> character into the position <span class="tt">slen + 1</span>. This trailing <span class="tt">NULL</span> character is not required for bstrings input to the bstring functions; this is provided solely as a convenience for interoperability with standard C char-buffer functionality.</p>
<p>Analogs for the ANSI C string library functions have been created when they are necessary, but have also been left out when they are not. In particular there are no functions analogous to <span class="tt">fwrite</span>, or <span class="tt">puts</span> just for the purposes of bstring. The <span class="tt">data</span> member of any string is exposed, and therefore can be used just as easily as char buffers for C functions which read strings.</p>
<p>For those that wish to hand construct bstrings, the following should be kept in mind:</p>
<ol type="1">
<li>While bstrlib can accept constructed bstrings without terminating <span class="tt">NULL</span> characters, the rest of the C language string library will not function properly on such non-terminated strings. This is obvious but must be kept in mind.</li>
<li>If it is intended that a constructed bstring be written to by the bstring library functions then the data portion should be allocated by the malloc function and the <span class="tt">slen</span> and <span class="tt">mlen</span> fields should be entered properly. The struct tagbstring header is not reallocated, and only freed by bdestroy.</li>
<li>Writing arbitrary <span class="tt">NULL</span> characters at various places in the string will not modify its length as perceived by the bstring library functions. In fact, <span class="tt">NULL</span> is a legitimate non-terminating character for a bstring to contain.</li>
<li>For read only parameters bstring functions do not check the <span class="tt">mlen</span>, i.e., the minimal correctness requirements are reduced to <span class="tt">(slen &gt;= 0 &amp;&amp; data != NULL)</span>.</li>
</ol>
<h1 class="doxsection"><a class="anchor" id="autotoc_md17"></a>
Better Pointer Arithmetic</h1>
<p>One built-in feature of <span class="tt">NULL</span> terminated <span class="tt">char *</span> strings, is that its very easy and fast to obtain a reference to the tail of any string using pointer arithmetic. Bstrlib does one better by providing a way to get a reference to any substring of a bstring (or any other length delimited block of memory). So rather than just having pointer arithmetic, with bstrlib one essentially has segment arithmetic. This is achieved using the macro <span class="tt">blk2tbstr</span> which builds a reference to a block of memory and the macro <span class="tt">bmid2tbstr</span> which builds a reference to a segment of a bstring. Bstrlib also includes functions for direct consumption of memory blocks into bstrings, namely <span class="tt">bcatblk</span> and <span class="tt">blk2bstr</span>.</p>
<p>One scenario where this can be extremely useful is when string contains many substrings which one would like to pass as read-only reference parameters to some string consuming function without the need to allocate entire new containers for the string data. More concretely, imagine parsing a command line string whose parameters are space delimited. This can only be done for tails of the string with <span class="tt">NULL</span> terminated <span class="tt">char *</span> strings.</p>
<h1 class="doxsection"><a class="anchor" id="autotoc_md18"></a>
Improved NULL Semantics and Error Handling</h1>
<p>Unless otherwise noted, if a NULL pointer is passed as a bstring or any other detectably illegal parameter, the called function will return with an error indicator (either <span class="tt">NULL</span> or <span class="tt">BSTR_ERR</span>) rather than simply performing a <span class="tt">NULL</span> pointer access, or having undefined behavior.</p>
<p>To illustrate the value of this, consider the following example: </p><pre class="fragment">strcpy(p = malloc (13 * sizeof(char)), "Hello,");
strcat(p, " World");
</pre><p>This is not correct because <span class="tt">malloc</span> may return NULL (due to an out of memory condition), and the behaviour of <span class="tt">strcpy</span> is undefined if either of its parameters are NULL. The following however, is well defined: </p><pre class="fragment">bstrcat(p = bfromcstr("Hello,"), q = bfromcstr(" World"));
bdestroy(q);
</pre><p>If either p or q are assigned NULL (indicating a failure to allocate memory) both bstrcat and bdestroy will recognize it and perform no detrimental action.</p>
<p>Note that it is not necessary to check any of the members of a returned bstring for internal correctness (in particular the data member does not need to be checked against <span class="tt">NULL</span> when the header is non-<span class="tt">NULL</span>), since this is assured by the bstring library itself.</p>
<h1 class="doxsection"><a class="anchor" id="autotoc_md19"></a>
bStreams</h1>
<p>In addition to the <span class="tt">bgets</span> and <span class="tt">bread</span> functions, bstrlib can abstract streams with a high performance read only stream called a bStream. In general, the idea is to open a core stream (with something like <span class="tt">fopen</span>) then pass its handle as well as a <span class="tt">bNread</span> function pointer (like <span class="tt">fread</span>) to the <span class="tt">bsopen</span> function which will return a handle to an open bStream. Then the functions <span class="tt">bsread</span>, <span class="tt">bsreadln</span> or <span class="tt">bsreadlns</span> can be called to read portions of the stream. Finally, the <span class="tt">bsclose</span> function is called to close the <span class="tt">bStream</span> &ndash; it will return a handle to the original (core) stream. So bStreams, essentially, wrap other streams.</p>
<p>The bStreams have two main advantages over the <span class="tt">bgets</span> and <span class="tt">bread</span> (as well as <span class="tt">fgets</span>/<span class="tt">ungetc</span>) paradigms:</p>
<ol type="1">
<li>Improved functionality via the <span class="tt">bunread</span> function (which allows a stream to unread characters) and giving the bStream stack-like functionality if so desired.</li>
<li>A very high performance <span class="tt">bsreadln</span> function. The C library function <span class="tt">fgets</span> (and the <span class="tt">bgets</span> function) can typically be written as a loop on top of <span class="tt">fgetc</span>, thus paying all of the overhead costs of calling <span class="tt">fgetc</span> on a per character basis. <span class="tt">bsreadln</span> will read blocks at a time, thus amortizing the overhead of <span class="tt">fread</span> calls over many characters at once.</li>
</ol>
<p>However, clearly bStreams are suboptimal or unusable for certain kinds of streams, e.g. <span class="tt">stdin</span>, or certain usage patterns (a few spotty, or non-sequential reads from a slow stream). For those situations, using <span class="tt">bgets</span> is appropriate.</p>
<p>The semantics of bStreams allows practical construction of layerable data streams. What this means is that by writing a <span class="tt">bNread</span> compatible function on top of a bStream, one can construct a new bStream on top of it. This can be useful for writing multi-pass parsers that don't actually read the entire input more than once and don't require the use of intermediate storage.</p>
<h1 class="doxsection"><a class="anchor" id="autotoc_md20"></a>
Aliasing</h1>
<p>Aliasing occurs when a function is given two parameters which point to data structures which overlap in the memory they occupy. While this does not disturb read only functions, for many libraries this can make functions that write to these memory locations malfunction. This is a common problem of the C standard library and especially the string functions in the C standard library.</p>
<p>The C standard string library is entirely chararacter by character oriented (as is bstring) which makes conforming implementations alias safe for some scenarios. However no actual detection of aliasing is typically performed, so it is easy to find cases where the aliasing will cause anomolous or undesirable behaviour (consider: <span class="tt">strcat(p, p)</span>). The C99 standard includes the <span class="tt">restrict</span> pointer modifier which allows the compiler to document and assume a no-alias condition on usage. However, only the most trivial cases can be caught (if at all) by the compiler at compile time, and thus there is no actual enforcement of non-aliasing.</p>
<p>Bstrlib, by contrast, permits aliasing and is completely aliasing safe, in the C99 sense of aliasing. That is to say, under the assumption that pointers of incompatible types from distinct objects can never alias, bstrlib is completely aliasing safe. (In practice this means that the data buffer portion of any bstring and header of any bstring are assumed to never alias). With the exception of the reference building macros, the library behaves as if all read-only parameters are first copied and replaced by temporary non-aliased parameters before any writing to any output bstring is performed (though actual copying is extremely rarely ever done).</p>
<p>Besides being a useful safety feature, bstring searching/comparison functions can improve to O(1) execution when aliasing is detected.</p>
<p>Note that aliasing detection and handling code in Bstrlib is generally extremely cheap. There is almost never any appreciable performance penalty for using aliased parameters.</p>
<h1 class="doxsection"><a class="anchor" id="autotoc_md21"></a>
Reenterancy</h1>
<p>Nearly every function in Bstrlib is a leaf function, and is completely reenterable with the exception of writing to common bstrings. The split functions which use a callback mechanism requires only that the source string not be destroyed by the callback function unless the callback function returns with an error status (note that Bstrlib functions which return an error do not modify the string in any way.) The string can in fact be modified by the callback and the behaviour is deterministic. See the documentation of the various split functions for more details.</p>
<h1 class="doxsection"><a class="anchor" id="autotoc_md22"></a>
Undefined Scenarios</h1>
<p>One of the basic important premises for Bstrlib is to not to increase the propogation of undefined situations from parameters that are otherwise legal in of themselves. In particular, except for extremely marginal cases, usages of bstrings that use the bstring library functions alone cannot lead to any undefined action. But due to C language and library limitations, there is no way to define a non-trivial library that is completely without undefined operations. All such possible undefined operations are described below:</p>
<ol type="1">
<li>Bstrings or struct tagbstrings that are not explicitely initialized cannot be passed as a parameter to any bstring function.</li>
<li>The members of the <span class="tt">NULL</span> bstring cannot be accessed directly. (Though all APIs and macros detect the <span class="tt">NULL</span> bstring.)</li>
<li>A bstring whose data member has not been obtained from a <span class="tt">malloc</span> or compatible call and which is write accessible passed as a writable parameter will lead to undefined results, i.e., do not <span class="tt">writeAllow</span> any constructed bstrings unless the data portion has been obtained from the heap.</li>
<li>If the headers of two strings alias but are not identical (which can only happen via a defective manual construction) then passing them to a bstring function in which one is writable is not defined.</li>
<li>If the <span class="tt">mlen</span> member is larger than the actual accessible length of the data member for a writable bstring, or if the <span class="tt">slen</span> member is larger than the readable length of the data member for a readable bstring, then the corresponding bstring operations are undefined.</li>
<li>Any bstring definition whose header or accessible data portion has been assigned to inaccessible or otherwise illegal memory clearly cannot be acted upon by the bstring library in any way.</li>
<li>Destroying the source of an incremental split from within the callback and not returning with a negative value (indicating that it should abort) will lead to undefined behaviour, although <em>modifying</em> or adjusting the state of the source data (even if those modifications fail within the bstrlib API) has well defined behavior.</li>
<li>Modifying a bstring which is write protected by direct access has undefined behavior.</li>
</ol>
<p>While this may seem like a long list (with the exception of invalid uses of the <span class="tt">writeAllow</span> macro) and source destruction during an iterative split without an accompanying abort, no usage of the bstring API alone can cause any undefined scenario to occur. The policy of restricting usage of bstrings to the bstring API can significantly reduce the risk of runtime errors (in practice it should eliminate them) related to string manipulation due to undefined action.</p>
<h1 class="doxsection"><a class="anchor" id="autotoc_md23"></a>
Multithreading</h1>
<p>A mutable bstring is kind of analogous to a small (two entry) linked list allocated by <span class="tt">malloc</span>, with all aliasing completely under programmer control. Manipulation of one bstring will never affect any other distinct bstring unless explicitely constructed to do so by the programmer via hand construction or via building a reference. Bstrlib also does not use any static or global storage, so there are no hidden unremovable race conditions. Bstrings are also clearly not inherently thread local. So just like <span class="tt">char *</span>, bstrings can be passed around from thread to thread and shared and so on, so long as modifications to a bstring correspond to some kind of exclusive access lock as should be expected (or if the bstring is read-only, which can be enforced by bstring write protection) for any sort of shared object in a multithreaded environment.</p>
<h1 class="doxsection"><a class="anchor" id="autotoc_md24"></a>
Problems Not Solved</h1>
<p>Bstrlib is written for the C languages, which have inherent weaknesses that cannot be easily solved:</p>
<ol type="1">
<li>Memory leaks: Forgetting to call <span class="tt">bdestroy</span> on a bstring that is about to be unreferenced, just as forgetting to call free on a heap buffer that is about to be dereferenced. Though bstrlib itself is leak free.</li>
<li>Read before write usage: In C, declaring an auto bstring does not automatically fill it with legal/valid contents. (The <span class="tt">bstrDeclare</span> and <span class="tt">bstrFree</span> macros from bstraux can be used to help mitigate this problem).</li>
</ol>
<p>Other problems not addressed:</p>
<ol type="1">
<li>Built-in mutex usage to automatically avoid all bstring internal race conditions in multitasking environments: The problem with trying to implement such things at this low a level is that it is typically more efficient to use locks in higher level primitives. There is also no platform independent way to implement locks or mutexes.</li>
<li>Unicode/wide character support.</li>
</ol>
<blockquote class="doxtable">
<p>Note: except for spotty support of wide characters, the default C standard library does not address any of these problems either. </p>
</blockquote>
<h1 class="doxsection"><a class="anchor" id="autotoc_md25"></a>
The <span class="tt">bstest</span> Module</h1>
<p>The bstest module is just a unit test for the bstrlib module. For correct implementations of bstrlib, it should execute with 0 failures being reported. This test should be utilized if modifications/customizations to bstrlib have been performed. It tests each core bstrlib function with bstrings of every mode (read-only, NULL, static and mutable) and ensures that the expected semantics are observed (including results that should indicate an error). It also tests for aliasing support. Passing bstest is a necessary but not a sufficient condition for ensuring the correctness of the bstrlib module.</p>
<h1 class="doxsection"><a class="anchor" id="autotoc_md26"></a>
Using Bstring an Alternative to the C Library</h1>
<p>First let us give a table of C library functions and the alternative bstring functions that should be used instead of them.</p>
<table class="doxtable">
<tr>
<th>C-library</th><th>Bstring Alternative</th></tr>
<tr>
<td>gets</td><td>bgets</td></tr>
<tr>
<td>strcpy</td><td>bassign</td></tr>
<tr>
<td>strncpy</td><td>bassignmidstr</td></tr>
<tr>
<td>strcat</td><td>bconcat</td></tr>
<tr>
<td>strncat</td><td>bconcat+btrunc</td></tr>
<tr>
<td>strtok</td><td>bsplit,bsplits</td></tr>
<tr>
<td>sprintf</td><td>bformat</td></tr>
<tr>
<td>snprintf</td><td>bformat + btrunc</td></tr>
<tr>
<td>vsprintf</td><td>bvformata</td></tr>
<tr>
<td>vsnprintf</td><td>bvformata + btrunc</td></tr>
<tr>
<td>vfprintf</td><td>bvformata + fputs</td></tr>
<tr>
<td>strcmp</td><td>biseq, bstrcmp</td></tr>
<tr>
<td>strncmp</td><td>bstrncmp, memcmp</td></tr>
<tr>
<td>strlen</td><td>slen, blength</td></tr>
<tr>
<td>strdup</td><td>bstrcpy</td></tr>
<tr>
<td>strset</td><td>bpattern</td></tr>
<tr>
<td>strstr</td><td>binstr</td></tr>
<tr>
<td>strpbrk</td><td>binchr</td></tr>
<tr>
<td>stricmp</td><td>bstricmp</td></tr>
<tr>
<td>strlwr</td><td>btolower</td></tr>
<tr>
<td>strupr</td><td>btoupper</td></tr>
<tr>
<td>strrev</td><td>bReverse (aux module)</td></tr>
<tr>
<td>strchr</td><td>bstrchr</td></tr>
<tr>
<td>strspnp</td><td>usestrspn</td></tr>
<tr>
<td>ungetc</td><td>bsunread</td></tr>
</table>
<p>The top 9 C functions listed here are troublesome in that they impose memory management in the calling function. The Bstring and CBstring interfaces have built-in memory management, so there is far less code with far less potential for buffer overrun problems. strtok can only be reliably called as a "leaf" calculation, since it (quite bizarrely) maintains hidden internal state. And gets is well known to be broken no matter what. The Bstrlib alternatives do not suffer from those sorts of problems.</p>
<p>The substitute for <span class="tt">strncat</span> can be performed with higher performance by using the <span class="tt">blk2tbstr</span> macro to create a presized second operand for <span class="tt">bconcat</span>.</p>
<table class="doxtable">
<tr>
<th>C-library</th><th>Bstring alternative</th></tr>
<tr>
<td>strspn</td><td>strspn acceptable</td></tr>
<tr>
<td>strcspn</td><td>strcspn acceptable</td></tr>
<tr>
<td>strnset</td><td>strnset acceptable</td></tr>
<tr>
<td>printf</td><td>printf acceptable</td></tr>
<tr>
<td>puts</td><td>puts acceptable</td></tr>
<tr>
<td>fprintf</td><td>fprintf acceptable</td></tr>
<tr>
<td>fputs</td><td>fputs acceptable</td></tr>
<tr>
<td>memcmp</td><td>memcmp acceptable</td></tr>
</table>
<p>Remember that Bstring functions will automatically append the <span class="tt">NULL</span> character to the character data buffer. So by simply accessing the data buffer directly, ordinary C string library functions can be called directly on them. Note that <span class="tt">bstrcmp</span> is not the same as <span class="tt">memcmp</span> in exactly the same way that <span class="tt">strcmp</span> is not the same as <span class="tt">memcmp</span>.</p>
<table class="doxtable">
<tr>
<th>C-library</th><th>Bstring alternative</th></tr>
<tr>
<td>fread</td><td>balloc + fread</td></tr>
<tr>
<td>fgets</td><td>balloc + fgets</td></tr>
</table>
<p>These are odd ones because of the exact sizing of the buffer required. The Bstring alternatives requires that the buffers are forced to hold at least the prescribed length, then just use <span class="tt">fread</span> or <span class="tt">fgets</span> directly. However, typically the automatic memory management of Bstring will make the typical use of <span class="tt">fgets</span> and <span class="tt">fread</span> to read specifically sized strings unnecessary.</p>
<h1 class="doxsection"><a class="anchor" id="autotoc_md27"></a>
Implementation Choices</h1>
<h2 class="doxsection"><a class="anchor" id="autotoc_md28"></a>
Overhead</h2>
<p>The bstring library has more overhead versus straight char buffers for most functions. This overhead is essentially just the memory management and string header allocation. This overhead usually only shows up for small string manipulations. The performance loss has to be considered in light of the following:</p>
<ol type="1">
<li>What would be the performance loss of trying to write this management code in one's own application?</li>
<li>Since the bstring library source code is given, a sufficiently powerful modern inlining globally optimizing compiler can remove function call overhead.</li>
</ol>
<p>Since the data type is exposed, a developer can replace any unsatisfactory function with their own inline implementation. And that is besides the main point of what the better string library is mainly meant to provide. Any overhead lost has to be compared against the value of the safe abstraction for coupling memory management and string functionality.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md29"></a>
Performance of the C Interface</h2>
<p>The algorithms used have performance advantages versus the analogous C library functions. For example:</p>
<ol type="1">
<li><p class="startli"><span class="tt">bfromcstr</span>/<span class="tt">blk2str</span>/<span class="tt">bstrcpy</span> versus <span class="tt">strcpy</span>/<span class="tt">strdup</span></p>
<p class="startli">By using <span class="tt">memmove</span> instead of <span class="tt">strcpy</span>, the break condition of the copy loop is based on an independent counter (that should be allocated in a register) rather than having to check the results of the load. Modern out-of-order executing CPUs can parallelize the final branch mis-predict penality with the loading of the source string. Some CPUs will also tend to have better built-in hardware support for counted memory moves than load-compare-store. This is a minor, but non-zero gain.</p>
</li>
<li><p class="startli"><span class="tt">biseq</span> versus <span class="tt">strcmp</span></p>
<p class="startli">If the strings are unequal in length, <span class="tt">bsiseq</span> will return in O(1) time. If the strings are aliased, or have aliased data buffers, biseq will return in O(1) time. strcmp will always be O(k), where k is the length of the common prefix or the whole string if they are identical.</p>
</li>
<li><p class="startli"><span class="tt">slen</span> versus <span class="tt">strlen</span></p>
<p class="startli"><span class="tt">slen</span> is obviously always O(1), while <span class="tt">strlen</span> is always O(n) where <em>n</em> is the length of the string.</p>
</li>
<li><p class="startli"><span class="tt">bconcat</span> versus <span class="tt">strcat</span></p>
<p class="startli">Both rely on precomputing the length of the destination string argument, which will favor the bstring library. On iterated concatenations the performance difference can be enormous.</p>
</li>
<li><p class="startli"><span class="tt">bsreadln</span> versus <span class="tt">fgets</span></p>
<p class="startli">The <span class="tt">bsreadln</span> function reads large blocks at a time from the given stream, then parses out lines from the buffers directly. Some C libraries will implement fgets as a loop over single fgetc calls. Testing indicates that the bsreadln approach can be several times faster for fast stream devices (such as a file that has been entirely cached.)</p>
</li>
<li><p class="startli"><span class="tt">bsplits</span>/<span class="tt">bsplitscb</span> versus <span class="tt">strspn</span></p>
<p class="startli">Accelerators for the set of match characters are generated only once.</p>
</li>
<li><p class="startli"><span class="tt">binstr</span> versus <span class="tt">strstr</span></p>
<p class="startli">The <span class="tt">binstr</span> implementation unrolls the loops to help reduce loop overhead. This will matter if the target string is long and source string is not found very early in the target string. With <span class="tt">strstr</span>, while it is possible to unroll the source contents, it is not possible to do so with the destination contents in a way that is effective because every destination character must be tested against <span class="tt">NULL</span> before proceeding to the next character.</p>
</li>
<li><p class="startli"><span class="tt">bReverse</span> versus <span class="tt">strrev</span></p>
<p class="startli">The C function must find the end of the string first before swaping character pairs.</p>
</li>
<li><p class="startli"><span class="tt">bstrrchr</span> versus no comparable C function</p>
<p class="startli">Its not hard to write some C code to search for a character from the end going backwards. But there is no way to do this without computing the length of the string with <span class="tt">strlen</span>.</p>
</li>
</ol>
<p>Practical testing indicates that in general Bstrlib is never signifcantly slower than the C library for common operations, while very often having a performance advantage that ranges from significant to massive. Even for functions like <span class="tt">bninchr</span> versus <span class="tt">strspn</span> (where, in theory, there is no advantage for the Bstrlib architecture) the performance of Bstrlib is vastly superior to most tested C library implementations.</p>
<p>Some of Bstrlib's extra functionality also lead to inevitable performance advantages over typical C solutions. For example, using the <span class="tt">blk2tbstr</span> macro, one can (in O(1) time) generate an internal substring by reference while not disturbing the original string. If disturbing the original string is not an option, typically, a comparable <span class="tt">char *</span> solution would have to make a copy of the substring to provide similar functionality. Another example is reverse character set scanning &ndash; the <span class="tt">strspn</span> functions only scan in a forward direction which can complicate some parsing algorithms.</p>
<p>Where high performance <span class="tt">char *</span> based algorithms are available, Bstrlib can still leverage them by accessing the <span class="tt">data</span> field on bstrings. So realistically Bstrlib can never be significantly slower than any standard <span class="tt">NULL</span> terminated <span class="tt">char *</span> based solutions.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md30"></a>
Memory Management</h2>
<p>The bstring functions which write and modify bstrings will automatically reallocate the backing memory for the char buffer whenever it is required to grow. The algorithm for resizing chosen is to snap up to sizes that are a power of two which are sufficient to hold the intended new size. Memory reallocation is not performed when the required size of the buffer is decreased. This behavior can be relied on, and is necessary to make the behaviour of balloc deterministic. This trades off additional memory usage for decreasing the frequency for required reallocations:</p>
<ol type="1">
<li>For any bstring whose size never exceeds n, its buffer is not ever reallocated more than <span class="tt">log2(n)</span> times for its lifetime.</li>
<li>For any bstring whose size never exceeds <em>n</em>, its buffer is never more than <span class="tt">2 * (n + 1)</span> in length. (The extra characters beyond <span class="tt">2 * n</span> are to allow for the implicit <span class="tt">NULL</span> which is always added by the bstring modifying functions).</li>
</ol>
<p>Decreasing the buffer size when the string decreases in size would violate 1. above and in real world case lead to pathological heap thrashing. Similarly, allocating more tightly than "least power of 2 greater than necessary" would lead to a violation of 1. and have the same potential for heap thrashing.</p>
<p>Property 2. needs emphasizing. Although the memory allocated is always a power of 2, for a bstring that grows linearly in size, its buffer memory also grows linearly, not exponentially. The reason is that the amount of extra space increases with each reallocation, which decreases the frequency of future reallocations.</p>
<p>Obviously, given that bstring writing functions may reallocate the data buffer backing the target bstring, one should not attempt to cache the data buffer address and use it after such bstring functions have been called. This includes making reference struct tagbstrings which alias to a writable bstring.</p>
<p><span class="tt">balloc</span> or <span class="tt">bfromcstralloc</span> can be used to preallocate the minimum amount of space used for a given bstring. This will reduce even further the number of times the data portion is reallocated. If the length of the string is never more than one less than the memory length then there will be no further reallocations.</p>
<p>Note that invoking the <span class="tt">bwriteallow</span> macro may increase the number of <span class="tt">realloc</span>s by one more than necessary for every call to bwriteallow interleaved with any bstring API which writes to this bstring.</p>
<p>The library does not use any mechanism for automatic clean up for the C API. Thus explicit clean up via calls to <span class="tt">bdestroy</span> are required to avoid memory leaks.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md31"></a>
Constant and Static <span class="tt">tagbstrings</span></h2>
<p>A <span class="tt">struct tagbstring</span> can be write protected from any bstrlib function using the <span class="tt">bwriteprotect</span> macro. A write protected <span class="tt">struct tagbstring</span> can then be reset to being writable via the <span class="tt">bwriteallow</span> macro. There is, of course, no protection from attempts to directly access the bstring members. Modifying a bstring which is write protected by direct access has undefined behavior.</p>
<p>static <span class="tt">struct tagbstrings</span> can be declared via the <span class="tt">bsStatic</span> macro. They are considered permanently unwritable. Such struct tagbstrings's are declared such that attempts to write to it are not well defined. Invoking either <span class="tt">bwriteallow</span> or <span class="tt">bwriteprotect</span> on static struct tagbstrings has no effect.</p>
<p><span class="tt">struct tagbstring</span>s initialized via <span class="tt">btfromcstr</span> or <span class="tt">blk2tbstr</span> are protected by default but can be made writeable via the bwriteallow macro. If <span class="tt">bwriteallow</span> is called on such <span class="tt">struct tagbstring</span>s, it is the programmer's responsibility to ensure that:</p>
<ol type="1">
<li>The buffer supplied was allocated from the heap.</li>
<li><span class="tt">bdestroy</span> is not called on this <span class="tt">tagbstring</span> unless the header itself has also been allocated from the heap.</li>
<li><span class="tt">free</span> is called on the buffer to reclaim its memory.</li>
</ol>
<p><span class="tt">bwriteallow</span> and <span class="tt">bwriteprotect</span> can be invoked on ordinary bstrings (they have to be dereferenced with the <span class="tt">*</span> operator to get the levels of indirection correct) to give them write protection.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md32"></a>
Buffer Declaration</h2>
<p>The memory buffer is actually declared <span class="tt">unsigned char *</span> instead of <span class="tt">char *</span>. The reason for this is to trigger compiler warnings whenever uncasted <span class="tt">char</span> buffers are assigned to the data portion of a bstring. This will draw more diligent programmers into taking a second look at the code where they have carelessly left off the typically required cast. (Research from AT&amp;T/Lucent indicates that additional programmer eyeballs is one of the most effective mechanisms at ferreting out bugs).</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md33"></a>
Function Pointers</h2>
<p>The <span class="tt">bgets</span>, <span class="tt">bread</span> and <span class="tt">bStream</span> functions use function pointers to obtain strings from data streams. The function pointer declarations have been specifically chosen to be compatible with the <span class="tt">fgetc</span> and <span class="tt">fread</span> functions. While this may seem to be a convoluted way of implementing <span class="tt">fgets</span> and <span class="tt">fread</span> style functionality, it has been specifically designed this way to ensure that there is no dependency on a single narrowly defined set of device interfaces, such as just stream I/O. In the embedded world, its quite possible to have environments where such interfaces may not exist in the standard C library form. Furthermore, the generalization that this opens up allows for more sophisticated uses for these functions (performing an <span class="tt">fgets</span> like function on a socket, for example.) By using function pointers, it also allows such abstract stream interfaces to be created using the bstring library itself while not creating a circular dependency.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md34"></a>
Use of <span class="tt">int</span> For Sizes</h2>
<p>This is just a recognition that 16bit platforms with requirements for strings that are larger than 64K and 32bit+ platforms with requirements for strings that are larger than 4GB are pretty marginal. The main focus is for 32bit platforms, and emerging 64bit platforms with reasonable &lt; 4GB string requirements. Using ints allows for negative values which has meaning internally to bstrlib.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md35"></a>
Semantic Consideration</h2>
<p>Certain care needs to be taken when copying and aliasing bstrings. A bstring is essentially a pointer type which points to a multipart abstract data structure. Thus usage, and lifetime of bstrings have semantics that follow these considerations. For example: </p><pre class="fragment">bstring a, b;
struct tagbstring t;

a = bfromcstr("Hello"); /* Create new bstring and copy "Hello" into it. */
b = a;                  /* Alias b to the contents of a. */
t = *a;                 /* Create a current instance pseudo-alias of a. */
bconcat(a, b);          /* Double a and b, t is now undefined. */
bdestroy(a);            /* Destroy the contents of both a and b. */
</pre><p>Variables of type bstring are really just references that point to real bstring objects. The equal operator creates aliases, and the asterisk dereference operator creates a kind of alias to the current instance (which is generally not useful for any purpose.) Using <span class="tt">bstrcpy</span> is the correct way of creating duplicate instances. The ampersand operator is useful for creating aliases to <span class="tt">struct tagbstrings</span> (remembering that constructed struct tagbstrings are not writable by default).</p>
<h1 class="doxsection"><a class="anchor" id="autotoc_md36"></a>
Security</h1>
<p>Bstrlib does not come with explicit security features outside of its fairly comprehensive error detection, coupled with its strict semantic support. That is to say that certain common security problems, such as buffer overrun, constant overwrite, arbitrary truncation etc, are far less likely to happen inadvertently. Where it does help, Bstrlib maximizes its advantage by providing developers a simple adoption path that lets them leave less secure string mechanisms behind. The library will not leave developers wanting, so they will be less likely to add new code using a less secure string library to add functionality that might be missing from Bstrlib.</p>
<p>That said there are a number of security ideas not addressed by Bstrlib:</p>
<ol type="1">
<li>Race condition exploitation (i.e., verifying a string's contents, then raising the privilege level and execute it as a shell command as two non-atomic steps) is well beyond the scope of what Bstrlib can provide. It should be noted that MFC's built-in string mutex actually does not solve this problem either &ndash; it just removes immediate data corruption as a possible outcome of such exploit attempts (it can be argued that this is worse, since it will leave no trace of the exploitation). In general race conditions have to be dealt with by careful design and implementation; it cannot be assisted by a string library.</li>
<li>Any kind of access control or security attributes to prevent usage in dangerous interfaces such as <span class="tt">system</span>. Perl includes a "trust" attribute which can be endowed upon strings that are intended to be passed to such dangerous interfaces. However, Perl's solution reflects its own limitations &ndash; notably that it is not a strongly typed language. In the example code for Bstrlib, there is a module called taint.cpp. It demonstrates how to write a simple wrapper class for managing "untainted" or trusted strings using the type system to prevent questionable mixing of ordinary untrusted strings with untainted ones then passing them to dangerous interfaces. In this way the security correctness of the code reduces to auditing the direct usages of dangerous interfaces or promotions of tainted strings to untainted ones.</li>
<li>Encryption of string contents is way beyond the scope of Bstrlib. Maintaining encrypted string contents in the futile hopes of thwarting things like using system-level debuggers to examine sensitive string data is likely to be a wasted effort (imagine a debugger that runs at a higher level than a virtual processor where the application runs). For more standard encryption usages, since the bstring contents are simply binary blocks of data, this should pose no problem for usage with other standard encryption libraries.</li>
</ol>
<h1 class="doxsection"><a class="anchor" id="autotoc_md37"></a>
Compatibility</h1>
<p>The Better String Library is known to compile and function correctly with the following compilers:</p>
<ul>
<li>GNU C/C++</li>
<li>Microsoft Visual C++</li>
<li>Watcom C/C++</li>
<li>Intel's C/C++ compiler (Windows)</li>
<li>The GNU C/C++ compiler (cygwin and Linux on PPC64)</li>
<li>Borland C</li>
<li>Turbo C</li>
</ul>
<p>Setting of configuration options should be unnecessary for these compilers (unless exceptions are being disabled or STLport has been added to WATCOM C/C++). Bstrlib has been developed with an emphasis on portability. As such porting it to other compilers should be straight forward. This package includes a porting guide (called porting.txt) which explains what issues may exist for porting Bstrlib to different compilers and environments.</p>
<h1 class="doxsection"><a class="anchor" id="autotoc_md38"></a>
ANSI issues</h1>
<ol type="1">
<li><p class="startli">The function pointer types <span class="tt">bNgetc</span> and <span class="tt">bNread</span> have prototypes which are very similar to, but not exactly the same as <span class="tt">fgetc</span> and <span class="tt">fread</span> respectively.</p>
<p class="startli">Basically the <span class="tt">FILE *</span> parameter is replaced by <span class="tt">void *</span>. The purpose of this was to allow one to create other functions with <span class="tt">fgetc</span> and <span class="tt">fread</span> like semantics without being tied to ANSI C's file streaming mechanism, i.e., one could very easily adapt it to sockets, or simply reading a block of memory, or procedurally generated strings (for fractal generation, for example.)</p>
<p class="startli">The problem is that invoking the functions <span class="tt">bNgetc</span>, <span class="tt">fgetc</span>, <span class="tt">bNread</span>, and <span class="tt">fread</span> is not technically legal in ANSI C. The reason being that the compiler is only able to coerce the function pointers themselves into the target type, however are unable to perform any cast (implicit or otherwise) on the parameters passed once invoked, i.e., if internally <span class="tt">void *</span> and <span class="tt">FILE *</span> need some kind of mechanical coercion, the compiler will not properly perform this conversion and thus lead to undefined behavior.</p>
<p class="startli">Apparently a platform from Data General called "Eclipse" and another from Tandem called "NonStop" have a different representation for pointers to bytes and pointers to words, for example, where coercion via casting is necessary. (Actual confirmation of the existence of such machines is hard to come by, so it is prudent to be skeptical about this information). However, this is not an issue for any known contemporary platforms. One may conclude that such platforms are effectively apocryphal even if they do exist.</p>
<p class="startli">To correctly work around this problem to the satisfaction of the ANSI limitations, one needs to create wrapper functions for fgets and/or fread with the prototypes of <span class="tt">bNgetc</span> and/or <span class="tt">bNread</span> respectively which performs no other action other than to explicitely cast the <span class="tt">void *</span> parameter to a <span class="tt">FILE *</span>, and simply pass the remaining parameters straight to the function pointer call.</p>
<p class="startli">The wrappers themselves are trivial: </p><pre class="fragment">size_t freadWrap(void *buff, size_t esz, size_t eqty, void *parm) {
    return fread(buff, esz, eqty, (FILE *) parm);
}

int fgetcWrap(void *parm) {
    return fgetc((FILE *)parm);
}
</pre><p class="startli">These have not been supplied in bstrlib or bstraux to prevent unnecessary linking with file I/O functions.</p>
</li>
<li><p class="startli">The <span class="tt">bstrlib</span> function names are not unique in the first 6 characters.</p>
<p class="startli">This is only an issue for older C compiler environments which do not store more than 6 characters for function names.</p>
</li>
</ol>
<h1 class="doxsection"><a class="anchor" id="autotoc_md39"></a>
Examples</h1>
<p>Dumping a line numbered file: </p><pre class="fragment">FILE *fp;
int i, ret;
struct bstrList * lines;
struct tagbstring prefix = bsStatic("-&gt; ");

if (NULL != (fp = fopen("bstrlib.txt", "rb"))) {
    bstring b = bread((bNread) fread, fp);
    fclose (fp);
    if (NULL != (lines = bsplit(b, '\n'))) {
        for (i=0; i &lt; lines-&gt;qty; i++) {
            binsert(lines-&gt;entry[i], 0, &amp;prefix, '?');
            printf("%04d: %s\n", i, bdatae(lines-&gt;entry[i], "NULL"));
        }
        bstrListDestroy(lines);
    }
    bdestroy(b);
}
</pre><p>For numerous other examples, see bstraux.c, bstraux.h and the example archive.</p>
<h1 class="doxsection"><a class="anchor" id="autotoc_md40"></a>
License</h1>
<p>Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:</p>
<ol type="1">
<li>Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.</li>
<li>Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.</li>
<li>Neither the name of bstrlib nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.</li>
</ol>
<p>THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</p>
<p>Alternatively, the contents of this file may be used under the terms of GNU General Public License Version 2 (the "GPL").</p>
<h1 class="doxsection"><a class="anchor" id="autotoc_md41"></a>
Acknowledgements</h1>
<p>The following individuals have made significant contributions to the design and testing of the Better String Library:</p>
<ul>
<li>Bjorn Augestad</li>
<li>Clint Olsen</li>
<li>Darryl Bleau</li>
<li>Fabian Cenedese</li>
<li>Graham Wideman</li>
<li>Ignacio Burgueno</li>
<li>International Business Machines Corporation</li>
<li>Ira Mica</li>
<li>John Kortink</li>
<li>Manuel Woelker</li>
<li>Marcel van Kervinck</li>
<li>Michael Hsieh</li>
<li>Richard A. Smith</li>
<li>Simon Ekstrom</li>
<li>Wayne Scott </li>
</ul>
</div></div><!-- PageDoc -->
<a href="doxygen_crawl.html"></a>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on <span class="timestamp"></span> for bstring by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.14.0
</small></address>
</div><!-- doc-content -->
</body>
</html>
